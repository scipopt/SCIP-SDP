/*  co-gcc.lnt: This is the seed file for configuring Lint for use with
    GCC versions 2.95.3 and later.

    Like all compiler options files this file is intended to be used
    as follows:

         lint co-gcc.lnt source-files-to-be-linted

    Some of the information that co-gcc.lnt requires needs to be furnished
    with the help of the gcc system itself.  The easiest way to generate
    this information is to use the makefile co-gcc.mak (supplied with the
    Lint distribution) in an invocation of GNU Make; for details, see the
    commentary at the top of co-gcc.mak.
*/

-cgnu             // Notifies FlexeLint that gcc is being used.

// load project definitions
project.lnt

// ===========================
// Preprocessor Configuration:
+fdi // GCC starts its #include search in the directory of the including
     // file.

-header(co-gcc.h) // Includes headers generated by GCC (bringing in
                  // predefined macros).
+libh(co-gcc.h)   // Marks that header as library code.

gcc-include-path.lnt // This .lnt file should contain --i options 
     // and should be generated by invoking gcc with its '-v' option.
     // (GCC's implicit #include search path is presented in the output.)
     // This happens automatically when 'make -f co-gcc.mak' is invoked.

// Assertion directives (a feature of GCC's preprocessor) have been
// considered obsolete in GCC's documentation since version 3.0, so we do
// not use them here.  If support for #assert is needed in the form of a
// lint option, one may use '-a#' like so:
// -a#machine(i386)  // #assert's machine(i386)  (SVR4 facility).

+cpp(.cc,.C)      // extensions for C++ that are commonly used in addition
                  // to the default extensions of .cpp and .cxx


// =============
// Size Options:
size-options.lnt // This .lnt file should be generated (preferrably
     // by a program created by invoking GCC with the compile options that
     // are used in the compilation of the project to be linted).  This
     // happens automatically when 'make -f co-gcc.mak' is invoked.


// ===========================================
// +rw and -d options to cope with GNU syntax:
+ppw(ident)                 // Tolerate #ident
+ppw(warning)

// GCC provides alternative spellings of certain keywords:
-rw_asgn(__inline,inline)
-rw_asgn(__inline__,inline)
-rw_asgn(__signed__,signed)
-rw_asgn(__signed,signed)
-rw_asgn( __volatile__, volatile )
-rw_asgn( __volatile, volatile )
++d__const=const        // gconv.h uses __const rather than const
++dconst=const          // ensure const expands to const.

-rw_asgn( asm,      _up_to_brackets )
-rw_asgn( __asm,    _up_to_brackets )
-rw_asgn( __asm__,  _up_to_brackets )
// This re-definition of the various spellings of the asm keyword enables
// Lint to pass gracefully over expression-statements like:
// __asm __volatile ("fsqrt" : "=t" (__result) : "0" (__x));
// But it may be necessary to suppress certain error messages that are
// triggered by tokens that are part of an assembly declaration or
// statement.  For example:

    -d"__asm__(p...)=/*lint -e{19}*/ __asm__(p)"

// ...causes Lint to be quiet about the semicolon that follows an
// __asm__() declaration.  Note, the -e{N} form of suppression takes
// effect only for the forward-declaration, definition or
// [possibly-compound] statement that immediately follows.  Because a
// semicolon is seen as a declaration-terminator, Error 19 will be
// re-enabled immediately after the semicolon in '__asm__(...);'.
// (The elipsis after the macro parameter p allows zero or more commas to
// appear in the operand.)
//
// If you encounter other diagnostics that appear to need suppression in
// or near assembly regions, please let us know!
-rw_asgn(__alignof__,__alignof)

++d__attribute__()=   // ignore this keyword and following parenthetical
++d__attribute()=     // variant spelling of "__attribute__"

// "__extension__" is GCC's way of allowing the use of non-standard
// constructs in a strict Standard-conforming mode.  We don't currently
// have explicit support for it, but we can use local suppressions.  For
// example, we can use -e(160) so that we will not see any Errors about
// GNU statement-expressions wrapped in __extension__().
++d"__extension__=/*lint -e(160) */"

++d__builtin_va_list=void*            // used by stdarg.h
++d__builtin_stdarg_start()=_to_semi  // ditto
++d__builtin_va_end()=_to_semi        // ditto
++d"__builtin_va_arg(a,b)=(*( (b *) ( ((a) += sizeof(b)) - sizeof(b) )))"
++d__null=0
+rw(_to_semi)           // needed for the two macros above.
+rw(__typeof__)         // activate __typeof__ keyword
-d__typeof=__typeof__   // an alternative to using __typeof__

+rw( __restrict )
+rw( __restrict__ )
-rw(__except)           // This MS reserved word is used as an identifier
+rw( __complex__, __real__, __imag__ )  // reserved words that can be ignored.
++d__builtin_strchr=(char*)     // permits the inline definition ...
++d__builtin_strpbrk=(char*)    // of these functions to be linted ...
++d__builtin_strrchr=(char*)    // without drawing a complaint
++d__builtin_strstr=(char*)     // about the use of a non-standard name
++d__PRETTY_FUNCTION__=___function___ // lint defines ___function___ internally
++d__FUNCTION__=___function___        // lint defines ___function___ internally
++d__func__=___function___  // Some C++ modes suport the implicit __func__
                            // identifier.

// =========================================================
// Other options supporting GNU C/C++ syntax:
+fld // enables the processing of _L_abel _D_esignators E.g.:
     // union { double d; int i; } u = { d: 3.141  };

// +fwc // wchar_t might be builtin; if so, uncomment
        // this option.

// =========================================================
// Generally useful suppressions:
-wlib(1)      // sets the warning level within library headers to 1
              // (no warnings, just syntax errors).  Comment out if you
              // are actually linting library headers.
-elib(123)    // 123 is really a warning, but it's in the "Error" range.
-elib(93)     // allow newlines within quoted string arguments to macros
-elib(46)     // allow bit fields to have integral types other than
              // '_Bool' and 'int'.
-elibsym(628) // Suppress 628 for __builtin symbols.

-esym(528,__huge_val,__nan,__qnan,__qnanf,__snan,__snanf)
                       // We don't care if we don't reference some GNU functions
-esym(528,__gnu_malloc,__gnu_calloc)

//  The following functions exhibit variable return modes.
//  That is, they may equally-usefully be called for a value
//  as called just for their effects.  Accordingly we inhibit
//  Warning 534 for these functions.
//  Feel free to add to or subtract from this list.

-esym(534,close,creat,fclose,fprintf,fputc)
-esym(534,fputs,fscanf,fseek,fwrite,lseek,memcpy,memmove,memset)
-esym(534,printf,puts,scanf,sprintf,sscanf,strcat,strcpy)
-esym(534,strncat,strncpy,unlink,write)

// For non-ANSI compilers we suppress messages 515 and 516
// for functions known to have variable argument lists.
// For ANSI compilers, header files should take care of this.

-esym(515,fprintf,printf,sprintf,fscanf,scanf,sscanf)
-esym(516,fprintf,printf,sprintf,fscanf,scanf,sscanf)
-esym(1702,*operator<<,*operator>>)
-esym(534,*operator<<,*operator>>)
-esym(1055,*__builtin*)
-esym(718,*__builtin*)   // The compiler does not need these ...
-esym(746,*__builtin*)   // declared and it knows their prototypes.

